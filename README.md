# Smart Patches project (January 2025 Hackathon at NSU)

## Актуальность (Motivation)

## Суть (In a nutshell)
Прототип инструмента применения гит-патчей - *рекурсивный интерпретатор* логического языка ***Hatch*** (в переводе "люк") с тремя операторами: `...`, `>>>`, `<<<`. 

### Предлагаемый алгоритм
В данный момент ключевой алгоритм основан на *лаконично сформулировать* и включает следующие шаги:
1. Парсинг входного Markdown-файла с комментариями, блоком инструкций на языке Hatch и блоком содержимого патча на языке исходного файла к которому применяется патч. Для удобства прототипирования и тестирования в этом файле также содержится и блок с исходным кодом патчуемого файла, однако в реальной ситуацией исходный файл живет в отдельном репозитории, а Markdown файл с патчем существует отдельно (в другом репозитории)  и включающет в себя три перечисленных части: комментарии для разработчиков, иструкции патча на Hatch и содержимое патча.
2. ...
3. ...


## Архитектура программного решения & структура репозитория
Прототип с базовым UI, простейшим парсером входных Markdown-файлов и юнит тестами разрабатывается в экосистеме языка программирования Python и *на данный момент использует только стандарнтую библиотеку* (скорее всего ситуации изменится и тогда имеет смысл привести список зависимостей ниже).

### Используемые библиотеки/фреймворки (Dependencies)

1. ? TextMate ? (ссылка на PIP или GitHub)
2. 

### Структура директорий в репозитории и их назначение

* `docs` - распечатки чатов, графика, схемы и материалы для подготовки отчетной презентации
    * `Hatch-grammar-essense.svg` - 
    * ... 
* `grammars` - XML файлы с описанием лексем для TextMate
    * `Python.tmLanguage` - грамматика языка Python
    * ...
* `source` - исходный код прототипа
    * `hatch` - библиотека с программной реализацией предлагаемых алгоритмов
        * `__init__.py` - "заголовочный" файл библиотеки
        * `language.py` - алгоритмическая структура
        * `expresions.py` - необходимые функционал регулярных выражений 
    * `main.py` - "каркасный модуль" / точка входа в программу / код интерфейса, парсера и юнит-тестов
* `tests` - тесты с подпапками по расширениям файлов с исходным кодом к которым применяется патч
    * `cpp` - тесты для C++
        * ...
        * `add_virtual.md` - один из множества элементарных юнит-тестов
        * ...
    * `py` - тесты для Python
        * ...
        * `add_virtual.md` - один из множества элементарных юнит-тестов
        * ...
 

## План разработки vs реальная хронология

* **Вторник: Реализация функции загрузки кода с помощью Markdown**
Задачи:
Разработать функцию для чтения Markdown-файлов, содержащих фрагменты кода.
Реализовать возможность извлечения блоков кода, выделенных с помощью тэгов Markdown (например, python, cpp).
Сохранить извлечённые блоки в структуре данных (например, словарь Python с указанием языка и содержимого блока).
Этапы:
Создать функцию load_code_from_markdown(filepath: str) -> dict, которая принимает путь к файлу и возвращает словарь с кодом.
Тестировать на примерах Markdown-файлов с разными языками программирования.

* **Среда: Определение логического языка для указания на блоки кода**
Задачи:
Разработать синтаксис логического языка для указания на функции, классы и блоки кода.
Реализовать парсер для обработки указаний.
Этапы:
Определить формат (например, module:class:function или file:line_range).
Создать функцию parse_logical_reference(reference: str) -> dict, которая разбирает строку указания на блок кода и возвращает структуру данных.
Добавить обработку ошибок для некорректных указаний.

* **Четверг: Реализация механизма поиска блоков кода**
Задачи:
Реализовать функцию поиска блоков кода по логическому указанию.
Поддерживать поиск по имени функции, классу или строкам.
Этапы:
Создать функцию find_code_block(reference: dict, code_data: dict) -> str, которая принимает указание и данные кода, возвращает найденный блок.
Тестировать на примерах, где указания ссылаются на функции, классы и строки.

* **Пятница: Вставка и обновление блоков кода в репозитории**
Задачи:
Реализовать функцию вставки кода в целевой репозиторий.
Обеспечить поддержку обновления существующих блоков кода.
Этапы:
Создать функцию insert_code_block(target_repo_path: str, reference: dict, new_code: str) -> None, которая добавляет или обновляет код.
Добавить сравнение существующего кода с новым, чтобы избежать дублирования.
Тестировать на примерах репозиториев.

* **Субота: Интеграция, тестирование и документация**
Задачи:
Интегрировать все функции в единую программу.
Написать юнит-тесты для каждой функции.
Подготовить документацию по использованию программы.
Этапы:
Создать интерфейс командной строки для запуска программы с параметрами.
Написать тесты с использованием unittest или pytest.
Оформить документацию в формате Markdown с примерами использования.


## Ресурсы (References)

1. [Интерпретаторы байт-кодов своими руками | Habr](https://habr.com/ru/companies/badoo/articles/425325/)
1. [Как я Markdown парсер выбирал | Habr](https://habr.com/ru/articles/672266/)
2. [Алгоритмы. Рекурсивные функции. | Habr](https://habr.com/ru/articles/857086/)
9. [Arend – язык с зависимыми типами, основанный на HoTT | Habr](https://habr.com/ru/companies/JetBrains-education/articles/469569/)

